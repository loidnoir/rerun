searchState.loadedDescShard("re_protos", 0, "This crate contains generated types for the remote store …\nCodec for serializing and deserializing query response …\nGenerated types for the remote store gRPC service API v0.\nDecode transport data from a byte stream - if there’s a …\nEncode a transport chunk into a byte stream.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncode a <code>NoData</code> message into a byte stream. This can be …\nHelper function that deserializes raw bytes into arrow …\nHelper function that serializes given arrow schema and …\nComponent describes semantic data that can be used by any …\nUsed to select a component based on its EntityPath and …\nThe unique identifier of an entity, e.g. <code>camera/3/points</code> …\nError codes for application level errors\nTODO(jleibs): Eventually this becomes either …\nmetadata database access error\nobject store access error\nunique recording identifier. At this point in time it is …\nRecording metadata is single row arrow record batch\nServer can include details about the error as part of gRPC …\narrow IPC serialized schema\nSpecifies how null values should be filled in the returned …\nUsed to telect a time column.\nA 64-bit number describing either nanoseconds, sequence …\nA time range between start and end time points. Each 64 …\nA recording can have multiple timelines, each is …\nunused\nerror code\ndefine which columns should be returned / projected we …\n/ The specific <em>columns</em> to sample from the final view …\nNested message and enum types in <code>ColumnSelector</code>.\nhuman readable description of the recording\nTODO(zehiko) we need to expand this to become something …\nTODO(zehiko) we need to expand this to become something …\nThe index used to filter out <em>rows</em> from the view contents. …\nThe range of index values used to filter out <em>rows</em> from the …\nThe specific index values used to filter out <em>rows</em> from the …\nThe component column used to filter out <em>rows</em> from the view …\nReturns the argument unchanged.\nWhether the view_contents should ignore columns …\nWhether the view_contents should ignore semantically empty …\nWhether the view_contents should ignore columns …\nCalls <code>U::from(self)</code>.\nhuman readable details about the error\n(optional) any additional metadata that should be …\nNote / TODO(zehiko): this implies we read the record (for …\ncomponent name needs to be a string as user can define …\npayload is raw bytes that the relevant codec can interpret\npayload is raw bytes that the relevant codec can interpret\nquery to execute\nunique identifier of the recording\nSpecifies how null values should be filled in the returned …\nGenerated client implementations.\nGenerated server implementations.\nrecording storage url (e.g. s3://bucket/file or …\nstorage url of the recording that failed to register\nTODO(zehiko) we need to add support for other types of …\nTODO(zehiko) support for other ranges for other index …\nTODO(zehiko) we need to add support for other types of …\ntype of recording\nThe specific index values used to sample <em>rows</em> from the …\nThe subset of the database that the query will run on: a …\nComponent describes semantic data that can be used by any …\nUsed to select a component based on its EntityPath and …\nThe unique identifier of an entity, e.g. <code>camera/3/points</code> …\nError codes for application level errors\nTODO(jleibs): Eventually this becomes either …\nmetadata database access error\nobject store access error\nunique recording identifier. At this point in time it is …\nRecording metadata is single row arrow record batch\nServer can include details about the error as part of gRPC …\narrow IPC serialized schema\nSpecifies how null values should be filled in the returned …\nUsed to telect a time column.\nA 64-bit number describing either nanoseconds, sequence …\nA time range between start and end time points. Each 64 …\nA recording can have multiple timelines, each is …\nunused\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nReturns the enum value of <code>code</code>, or the default if the …\nerror code\ndefine which columns should be returned / projected we …\n/ The specific <em>columns</em> to sample from the final view …\nNested message and enum types in <code>ColumnSelector</code>.\nGet metadata as arrow data\nhuman readable description of the recording\nReturns the enum value of <code>encoder_version</code>, or the default …\nReturns the enum value of <code>encoder_version</code>, or the default …\nReturns the enum value of <code>encoder_version</code>, or the default …\nTODO(zehiko) we need to expand this to become something …\nTODO(zehiko) we need to expand this to become something …\nThe index used to filter out <em>rows</em> from the view contents. …\nThe range of index values used to filter out <em>rows</em> from the …\nThe specific index values used to filter out <em>rows</em> from the …\nThe component column used to filter out <em>rows</em> from the view …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>SparseFillStrategy</code>, or <code>None</code> if <code>value</code> …\nConverts an <code>i32</code> to a <code>ErrorCode</code>, or <code>None</code> if <code>value</code> is not a …\nConverts an <code>i32</code> to a <code>EncoderVersion</code>, or <code>None</code> if <code>value</code> is …\nConverts an <code>i32</code> to a <code>RecordingType</code>, or <code>None</code> if <code>value</code> is …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nReturns unique id of the recording\nWhether the view_contents should ignore columns …\nWhether the view_contents should ignore semantically empty …\nWhether the view_contents should ignore columns …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>SparseFillStrategy</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>ErrorCode</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>EncoderVersion</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>RecordingType</code>.\nhuman readable details about the error\n(optional) any additional metadata that should be …\nNote / TODO(zehiko): this implies we read the record (for …\ncomponent name needs to be a string as user can define …\npayload is raw bytes that the relevant codec can interpret\npayload is raw bytes that the relevant codec can interpret\nquery to execute\nunique identifier of the recording\nSets <code>code</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>sparse_fill_strategy</code> to the provided enum value.\nSets <code>typ</code> to the provided enum value.\nReturns the enum value of <code>sparse_fill_strategy</code>, or the …\nSpecifies how null values should be filled in the returned …\nGenerated client implementations.\nGenerated server implementations.\nrecording storage url (e.g. s3://bucket/file or …\nstorage url of the recording that failed to register\nTODO(zehiko) we need to add support for other types of …\nTODO(zehiko) support for other ranges for other index …\nTODO(zehiko) we need to add support for other types of …\nCreate <code>RecordingMetadata</code> from <code>TransportChunk</code>. We rely on …\nReturns the enum value of <code>typ</code>, or the default if the field …\ntype of recording\nThe specific index values used to sample <em>rows</em> from the …\nThe subset of the database that the query will run on: a …\nEncodes the message to a buffer.\nReturns the encoded length of the message without a length …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecodes an instance of the message from a buffer, and …\nEnable decompressing responses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nmetadata API calls\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\ndata API calls\nCompress requests with the given encoding.\nServer streaming response type for the FetchRecording …\nServer streaming response type for the Query method.\nGenerated gRPC service name\nGenerated trait containing gRPC methods that should be …\nEnable decompressing requests with the given encoding.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nmetadata API calls\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\ndata API calls\nCompress responses with the given encoding, if the client …\nServer streaming response type for the FetchRecording …\nServer streaming response type for the Query method.\nGenerated gRPC service name\nGenerated trait containing gRPC methods that should be …\nmetadata API calls\ndata API calls")